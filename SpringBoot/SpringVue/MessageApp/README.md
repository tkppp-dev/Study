# 2,3장 MessageApp

MessageApp을 구현하는 스프링부트와 Vue.js 기술 


# 스프링부트
 
@ DI와 IoC
 제어의 역전(Inversion of Control) : 프로그램의 제어권을 프레임워크가 가지는 것
  - 의존관계 역전 원칙 : 1. 상위 모듈을 하위 모듈에 의존해서는 안된다. 2. 추상화는 세부사항에 의존해서는 안된다.
    단순하게 인터페이스를 통해 결합도를 낮추자는 의미로 해석 -> 인터페이스를 사용하면 의존하는 객체는 영향을 받지 않는다!
 의존성 주입(Dependency Injection) : 객체의 생명주기를 스프링 프레임워크에서 관리하는 것 -> 인스턴스 생성을 new로 직접 관리하는 것이 아닌 스프링에 맞기는 것을 의존성을 주입한다로 표현
   스프링부트는 @Configuration 어노테이션과 @ComponentScan 어노테이션의 경로를 통해 자동으로 @Component 어노테이션이 달린 클래스를 빈으로 등록한다.

   의존성 주입시 주입될 의존성을 연결해야하는데 크게 두가지 방법
   1. 생성자 기반 주입 : 생성자에 @Autowired로 의존성 연결, 생략 가능
   2. 세터 기반 주입 : 세터에  @Autowired, @Required로 의존성 연결
   3. 필드 기반 주입 : @Autowired로 주입

   Spring Docs는 1,2를 권장하며 특히 1을 권장함. 이유는 다음과 같다.
   생성자 기반 주입시
   NullPointerException 방지, final 키워드에도 주입 가능, 순환참조 검출 가능한 장점이 있어 권장함
   생성자 기반 주입시 코드가 더러워질 수 있어 리팩토링을 할 가능성이 있다는 단점이 있다.
   따라서 필수적인 의존성 주입이 필요한 경우 생성자 기반
   선택적 주입이 필요한 경우 세터(메서드) 기반 
   
   cf) 현재 클래스에 생성자가 존재하지 않는다. 하지만 실행시 잘 된다.
       ComponentScan을 하면서 빈을 등록할 때 의존성 연결부분이 존재하지 않으면 기본 생성자에
       의존성을 연결 하는 것으로 보인다. 아래와 같은 내용일 것으로 생각됨
       @Autowired
       public MessageRepository(){}
       
       => 틀림. 의존성이란 new 라고 할수 있다. 해당 클래스에는 의존성을 주입할 객체가 없다
       Component 어노테이션은 스프링에 빈을 등록하라는 의미이지 의존성을 주입하라는게 아니다
       
@ Spring AOP
  Join Point : 특정 프로그램(메소드)가 실행되는 지점
  Advise : 관심사(aspect)를 처리하는 행동이며 이 클래스에서는 checkSecurity 메소드가 해당된다
  
  어드바이스 지점
    @Before : 조인 포인트 이전에 실행되며 실행을 제어할 수 없다
    @AfterReturning : 예외없이 조인 포인트가 정상적으로 완료된후 실행
    @AfterThrowing : 예외를 던져 메소드가 종료될 때 실행
    @After : 예외의 존재 여부와 관련없이 조인포인트 이후에 실행, finally 구문이라고 생각하면 편함
    @Around : 코드 실행을 제어할 수 있는 어드바이스로 어드바이스 안에서 실행 여부를 결정한다
    
  PointCut : 일치하는 여러 조인포인트를 결합한 것으로 포인트컷 표현식으로 실행 위치를 지정 가능
    포인트컷에 대한 시그니처를 생성해 변수처럼 사용할 수도 있다
    PCD(@annotation)을 통해 특정 메소드를 지정할 수 있다
    
@ Spring Transcation
  - 추후 추가

@ 
       
    
 
 
